%D \module
%D   [       file=lxml-ini,
%D        version=2007.08.17,
%D          title=\CONTEXT\ \LUA\ based \XML\ Support,
%D       subtitle=Initialization,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

\writestatus{loading}{Context L-XML Macros (initialization)}

\registerctxluafile{lxml-ini}{1.001}

\unprotect

\def\xmlload            #1#2{\ctxlua{lxml.load("#1","#2")}}
\def\xmlloadbuffer      #1#2{\ctxlua{lxml.loadbuffer("#1","#2")}}
\def\xmlutfize            #1{\ctxlua{lxml.utfize("#1")}}
\def\xmlfirst           #1#2{\ctxlua{lxml.first("#1","#2")}}
\def\xmllast            #1#2{\ctxlua{lxml.last("#1","#2")}}
\def\xmlall             #1#2{\ctxlua{lxml.all("#1","#2")}}
\def\xmlfilter          #1#2{\ctxlua{lxml.filter("#1","#2")}}
\def\xmlcommand       #1#2#3{\ctxlua{lxml.command("#1","#2","#3")}}
\def\xmlnonspace        #1#2{\ctxlua{lxml.nonspace("#1","#2")}}
\def\xmltext            #1#2{\ctxlua{lxml.text("#1","#2")}}
\def\xmlcontent         #1#2{\ctxlua{lxml.content("#1","#2")}}
\def\xmlstripped        #1#2{\ctxlua{lxml.stripped("#1","#2")}}
\def\xmlstrip           #1#2{\ctxlua{lxml.strip("#1","#2")}}
\def\xmlflush             #1{\ctxlua{lxml.flush("#1")}}
\def\xmlindex         #1#2#3{\ctxlua{lxml.index("#1","#2",\number#3)}}
\def\xmlidx           #1#2#3{\ctxlua{lxml.idx("#1","#2",\number#3)}}
\def\xmlcount           #1#2{\ctxlua{lxml.count("#1","#2")}}
\def\xmlname              #1{\ctxlua{lxml.name("#1")}}
\def\xmlnamespace         #1{\ctxlua{lxml.namespace("#1")}}
\def\xmltag               #1{\ctxlua{lxml.tag("#1")}}
\def\xmlattribute     #1#2#3{\ctxlua{lxml.attribute("#1","#2","#3")}}
\def\xmlattributedef#1#2#3#4{\ctxlua{lxml.attribute("#1","#2","#3","#4")}}
\def\xmlatt             #1#2{\ctxlua{lxml.attribute("#1","/","#2")}}
\def\xmlattdef        #1#2#3{\ctxlua{lxml.attribute("#1","/","#2","#3")}}
\def\xmlconcat        #1#2#3{\ctxlua{lxml.concat("#1","#2",[[\detokenize{#3}]])}}
\def\xmlsetsetup      #1#2#3{\ctxlua{lxml.setsetup("#1","#2","#3")}}
\def\xmlsetfunction   #1#2#3{\ctxlua{lxml.setaction("#1","#2",#3)}}
\def\xmlloaddirectives    #1{\ctxlua{lxml.directives.load("#1")}}
\def\xmldirectives        #1{\ctxlua{lxml.directives.setups("#1")}}
\def\xmlregisterns      #1#2{\ctxlua{xml.registerns("#1","#2")}}                    % document
\def\xmlchecknamespace#1#2#3{\ctxlua{xml.check_namespace(lxml.id("#1"),"#2","#3")}} % element
\def\xmlremapname   #1#2#3#4{\ctxlua{xml.remapname(lxml.id("#1"),"#2","#3","#4")}}  % element
\def\xmlremapnamespace#1#2#3{\ctxlua{xml.rename_space(lxml.id("#1"),"#2","#3")}}    % document
\def\xmldelete          #1#2{\ctxlua{xml.delete(lxml.id("#1"),"#2")}}
\def\xmlinclude       #1#2#3{\ctxlua{lxml.include(lxml.id("#1"),"#2","#3",true)}}
\def\xmldoifelse        #1#2{\ctxlua{cs.testcase(xml.found(lxml.id("#1"),"#2",false))}}
\def\xmldoifelsetext    #1#2{\ctxlua{cs.testcase(xml.found(lxml.id("#1"),"#2",true ))}}
\def\xmlverbatim          #1{\ctxlua{lxml.verbatim(lxml.id("#1"))}}

\def\xmldoifelse        #1#2{\ctxlua{commands.doifelse(xml.found(lxml.id("#1"),"#2",false))}}
\def\xmldoifelsetext    #1#2{\ctxlua{commands.doifelse(xml.found(lxml.id("#1"),"#2",true ))}}
\def\xmldoif            #1#2{\ctxlua{commands.doif    (xml.found(lxml.id("#1"),"#2",false))}}
\def\xmldoiftext        #1#2{\ctxlua{commands.doif    (xml.found(lxml.id("#1"),"#2",true ))}}
\def\xmldoifnot         #1#2{\ctxlua{commands.doifnot (xml.found(lxml.id("#1"),"#2",false))}}
\def\xmldoifnottext     #1#2{\ctxlua{commands.doifnot (xml.found(lxml.id("#1"),"#2",true ))}}


% \startxmlsetups xml:include
%     \xmlinclude{main}{include}{filename|href}
% \stopxmlsetups
%
% \xmlprependsetup{xml:include}

\let\xmlgrab\xmlsetsetup

\def\xmlsetup#1#2%              % we pass the reference so that we have access to the frozen number
  {\def\xmlself{#1}%            % by using #1 inside a setup
   \setupwithargument{#2}{#1}}

\newtoks \registeredxmlsetups

\def\xmlappendsetup #1{\appendtoksonce \directsetup{#1}\to\registeredxmlsetups} % to be done, made faster
\def\xmlprependsetup#1{\prependtoksonce\directsetup{#1}\to\registeredxmlsetups} % to be done, made faster

\let\xmlregistersetup\xmlappendsetup

\def\xmlregisteredsetups
  {\the\registeredxmlsetups\registeredxmlsetups\emptytoks}

\def\doxmlprocess#1#2#3#4%
  {\begingroup
   \def\xmldocument{#2}%
   #1{#2}{#3}%
   \enableXML
   \doifelsenothing{#4}
     {\directsetup{xml:process}}
     {\directsetup{#4}}%
   \endgroup}

\def\xmlprocess      {\doxmlprocess\xmlload}
\def\xmlprocessbuffer{\doxmlprocess\xmlloadbuffer}

\startsetups xml:process
    \xmlregisteredsetups
    \xmlall\xmldocument{/}
\stopsetups

% \long\def\xmlloop#1#2#3%
%   {\dorecurse{\xmlcount{#1}{#2}}{\def\xmli####1####2{\xmlidx{#1}{#2/####1}{####2}}#3}}

\long\def\xmlloop#1#2#3%
  {\def\xmli##1##2{\xmlidx{#1}{#2/##1}{##2}}%
   \dorecurse{\xmlcount{#1}{#2}}{#3}}

\long\def\xmlconnect#1#2#3%
  {\scratchcounter\xmlcount{#1}{#2}\relax
   \ifcase\scratchcounter \or
       \xmlall{#1}{#2}%
   \else
       \dorecurse \scratchcounter {
           \ifnum\recurselevel>\plusone#3\fi
           \xmlidx{#1}{#2}{\recurselevel}
       }
   \fi}

\def\xmlcdataobeyedline {\obeyedline}
\def\xmlcdataobeyedspace{\strut\obeyedspace}
\def\xmlcdatabefore     {\bgroup\tt}
\def\xmlcdataafter      {\egroup}

% verbatim (dodo:pre/post whitespace, maybe splot verbatim and
% cdata commands), experimental:
%
% \xmlsetfunction{main}{verbatim}{lxml.displayverbatim}
% \xmlsetfunction{main}{verb}    {lxml.inlineverbatim}

% \def\startxmldisplayverbatim[#1]{}
% \def\stopxmldisplayverbatim     {}
% \def\startxmlinlineverbatim [#1]{}
% \def\stopxmlinlineverbatim      {}

% we use an xml: namespace so one has to define a suitable verbatim, say
%
% \definetyping[xml:verbatim][typing]
%
% this is experimental!

\def\startxmldisplayverbatim[#1]%
  {\startpacked % \begingroup
   \let\currenttypingclass\??tp
   \edef\currenttyping{xml:#1}%
   \def\stopxmldisplayverbatim
     {\endofverbatimlines
      \stoppacked} % \endgroup
   \mkinitializeverbatim
   \beginofverbatimlines}

\def\startxmlinlineverbatim[#1]%
  {\begingroup
   \let\currenttypingclass\??ty
   \edef\currenttyping{xml:#1}%
   \let\stopxmldisplayverbatim\endgroup
   \mkinitializeverbatim}

% will move but is developed for xml

\newtoks \collectingtoks

\def\startcollect#1\stopcollect
  {\collectingtoks\@EA{\the\collectingtoks#1}}

\def\startexpandedcollect#1\stopexpandedcollect
  {\expanded{\collectingtoks{\the\collectingtoks#1}}}

\def\startcollecting{\collectingtoks\emptytoks}
\def\stopcollecting {\the\collectingtoks}

\def\inlinemessage #1{\dontleavehmode{\tttf#1}}
\def\displaymessage#1{\blank\inlinemessage{#1}\blank}

% entities

\def\xmlresolveentities
  {\ctxlua{xml.set_text_cleanup(xml.set_text_cleanup(xml.resolve_text_entities))}}

\def\xmltraceentities
  {\ctxlua{xml.set_text_cleanup(lxml.trace_text_entities)}%
   \appendtoks\ctxlua{lxml.show_text_entities()}\to\everygoodbye}

% brrrr, give this at the top of a style that needs to stub mkiv loading

\def\processXMLfileMKIV
  {\dosingleempty\doprocessXMLfileMKIV}

\let\normalprocessXMLfilegrouped\processXMLfilegrouped

\def\doprocessXMLfileMKIV[#1]%
  {\def\processXMLfilegrouped##1%
     {\let\processXMLfilegrouped\normalprocessXMLfilegrouped
      \doifelsenothing{#1}{\xmlprocess{main}{##1}{}}{\xmlprocess{#1}{##1}{}}}}

\protect \endinput

% \xmlload{main}{normreader.xml}

% \xmlattribute{main}{/subject/information/materialoverview/attribute}{pocketbook}
% \xmltext{main}{/subject/information/materialoverview/@pocketbook}

% \dorecurse{\xmlflush{main}{/subject/blabla/count()}}
%    {\ifnum\recurselevel=\xmlflush{main}{/subject/blabla/count()}\relax
%         \removeunwantedspaces and\space\ignorespaces
%     \else\ifnum\recurselevel>1
%         \removeunwantedspaces,\space\ignorespaces
%     \fi
%     \xmlflush{main}{/subject/blabla/index(\recurselevel})}

% \def\xmljoin{main}{/subject/information/authors/author}{,}{and}
% table.join(t,1,#t-1,", ") .. " and " .. t[#t]
