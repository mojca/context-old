%D \module
%D   [       file=cont-new,
%D        version=2006.10.04,
%D          title=\CONTEXT\ Miscellaneous Macros,
%D       subtitle=New Macros,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

% \ctxlua { fonts.define.method = 2 }  % normally 3

\enablemode[mkiv] \setsystemmode{mkiv}

% there is more code here that is wise, but first we need to split
% more modules in mkii/mkiv

% potential new defaults:

% \setbreakpoints[compound]

\unprotect

% we have to make an mkii/mkiv core-not

\def\dochecknote % only to be called locally, some bools will become class-ones
  {% for the moment no mixed text/endnotes modes, so we use
   % \footnoteparameter and not \noteparameter (**)
   \setnotedistance
   \edef\notelocationasked{\noteparameter\c!location}% can be set
   \count\currentnoteins\plusthousand
   \expdoifcommonelse{\v!columns,\v!lastcolumn}\notelocationasked
     {\chardef\clevernotes\plustwo}
     {\expdoifinsetelse\v!firstcolumn\notelocationasked
        {\chardef\clevernotes\plusone}%
        {\chardef\clevernotes\zerocount}}%
   \ifcase\clevernotes\relax
     % notes not in column areas
     \ifnum\noteparameter\c!n=\zerocount % no ifcase
       \settextnotes
       \scratchcounter\plusone
     \else
       \setcolumnnotes
       \scratchcounter\noteparameter\c!n\relax
       \divide\count\currentnoteins \scratchcounter
     \fi
     \global\endnotesfalse
     \expdoifinsetelse\v!page\notelocationasked
       {\expdoifinsetelse\v!high\notelocationasked
          {\global\bottomnotesfalse}
          {\global\bottomnotestrue}}
       {\global\endnotestrue
        \global\bottomnotestrue}% not: \postponenotes, else global
    \else
      % notes in column areas
      \ifnum\@@kln=\zerocount % no ifcase / brrr dependency on \??kl
        \scratchcounter\plusone
      \else
        \scratchcounter\footnoteparameter\c!n\relax % **
      \fi
      \global\endnotesfalse
      \global\bottomnotestrue
      \setclevernotes
   \fi
   \doifsomething{\noteparameter\c!factor}
     {\ifnum\noteparameter\c!factor<\zerocount\else
        \count\currentnoteins\noteparameter\c!factor
      \fi}%
   \ifnotelimit
     \dimen\currentnoteins\noteparameter\c!height
     \multiply\dimen\currentnoteins \scratchcounter
   \fi
   \ifendnotes
     \dimen\currentnoteins\maxdimen
     \count\currentnoteins\zerocount
     \skip \currentnoteins\zeropoint
   \fi}

%

\def\writestatus#1#2{\ctxlua{ctx.writestatus(\!!bs#1\!!es,\!!bs#2\!!es)}}

\ifx\clearmarks\undefined
    \def\clearmarks  {\begingroup\afterassignment\doclearmarks\scratchcounter}
    \def\doclearmarks{\normalmarks\scratchcounter{}\endgroup}
\fi

\def\resetmark#1% we cannot use \normalmarks#1{}
  {\global\@EA\chardef\csname\@@mrk\string#1\endcsname\zerocount
   \@EA\clearmarks\csname\@@prk\string#1\endcsname
   \global\@EA\let\csname\@@trk\string#1\endcsname\empty
   \global\@EA\let\csname\@@frk\string#1\endcsname\empty
   \global\@EA\let\csname\@@brk\string#1\endcsname\empty
   \global\@EA\let\csname\@@crk\string#1\endcsname\empty}

%D Since this can be a showstopper, we report the path at the beginning
%D as well as at the end of a run.

% \writestatus\m!lua{used config path - \ctxlua{tex.print(caches.configpath())}}
% \writestatus\m!lua{used cache path  - \ctxlua{tex.print(caches.path)}}

%D For the moment we report some statistics. Later this will become an option,
%D but for now we need this information.

\def\nomkivstatistics{\ctxlua{function ctx.show_statistics() end}} % for taco

\def\resettimer    {\ctxlua{environment.starttime = os.clock()}}
\def\elapsedtime   {\ctxlua{tex.sprint(os.clock()-environment.starttime)}}
\let\elapsedseconds \elapsedtime

\resettimer

%D For me.

\def\traceluausage
  {\dosingleempty\dotraceluausage}

\def\dotraceluausage[#1]%
  {\ctxlua{debugger.enable()}%
   \appendtoks\ctxlua{debugger.disable() debugger.showstats(print,\doifnumberelse{#1}{#1}{5000})}\to\everybye}

%D Fonts (experimental AFM loading}

% \ctxlua {
%     remapper.define('encoding','^lm' ,'^(.*)$','lm-\letterpercent1')
%     remapper.define('encoding','^qbk','^(.*)$','q-\letterpercent1')
%     remapper.define('encoding','^qcs','^(.*)$','q-\letterpercent1')
%     remapper.define('encoding','^qpl','^(.*)$','q-\letterpercent1')
%     remapper.define('encoding','^qtm','^(.*)$','q-\letterpercent1')
% }

\appendtoksonce \loadallXfontmapfiles \to \everyPDFxform
\appendtoksonce \loadallXfontmapfiles \to \everyPDFximage
\appendtoksonce \loadallXfontmapfiles \to \everystarttext
\appendtoksonce \loadallXfontmapfiles \to \everybeforepagebody

\def\loadallXfontmapfiles{\ctxlua{fonts.map.flush("pdftex")}}

% \ctxlua{
%     do
%         local pth = "." .. io.fileseparator .. "tmp" .. io.fileseparator .. "\jobname"
%         texio.write_nl("CREATING "..pth)
%         os.execute("mkdir " .. pth)
%     end
%     input.output_files = { }
%     callback.register('find_write_file', function(id,name)
%         input.output_files[name] = file.join(".","tmp","\jobname",name)
%         texio.write_nl("REDIRECTING OUTPUT "..name.. " TO " .. input.output_files[name])
%         return input.output_files[name]
%     end)
%     callback.register('find_read_file', function(id,name)
%         local sname = string.gsub(name,"^\letterpercent./","")
%         if input.output_files[sname] then
%             return input.output_files[name]
%         elseif string.find(sname,"^\jobname[\letterpercent.\letterpercent-]") then
%             local n = file.join(".","tmp","\jobname",sname)
%             local f = io.open(n)
%             if f then
%                 input.output_files[name] = n
%                 texio.write_nl("REDIRECTING INPUT "..sname.. " TO " .. n)
%                 f:close()
%                 return n
%             else
%                 return input.findtexfile(name)
%             end
%         else
%             return input.findtexfile(name)
%         end
%     end)
% }

% The following commands need to be taken care of, e.g. because there is not yet
% a mkiv module for them. (Currently they're overloaded so we need to redefine them.)

\def\WORD {\groupedcommand{\setcharactercasing[\plusone  ]}{}}
\def\word {\groupedcommand{\setcharactercasing[\plustwo  ]}{}}
\def\Word {\groupedcommand{\setcharactercasing[\plusthree]}{}}
\def\Words{\groupedcommand{\setcharactercasing[\plusfour]}{}}

\let\WORDS\WORD
\let\words\word

\definestartstop[randomized][\c!before=\dosetattribute{case}{8},\c!after=]

\protect \endinput

% \expanded{\defineactivecharacter \number"2000E} {\textdir TRT\relax}
% \expanded{\defineactivecharacter \number"2000F} {\textdir TLT\relax}
